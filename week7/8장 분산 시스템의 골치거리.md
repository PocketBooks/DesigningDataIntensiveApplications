
> **실제 "분산" 환경**의 시스템에서 나타날 수 있는 다양한 에지 케이스 

> ~~기도에 영역~~ → 대처의 영역

### 요약 
- 분산시스템은 공유메모리 없이 (신뢰성 없는)네트워크에 의존
- 네트워크, 시계, 프로세스 는 사실 신뢰성이 없다
- 네트워크 실패 → 타임아웃..
    - 네트워크 선택 .. TCP / UDP
- 시계 → 동기화
- 프로세스 → 가비지컬렉터, I/O 등
- 리더, 잠금 (선거, 다수결)
- 나 안죽었어 ㅠㅠ (펜싱토큰) 
- 정직하지도 않다면? → 검증(체크섬)
- 관련 미들웨어: 주키퍼

-> 9장 **일관성과 합의** 에 위의 문제들의 시스템적 해결법에 대해 이야기 

## 결함과 부분 장애

내부 결함시 잘못된 결과보다 완전히 동작하지 않기를 바람

결정적 = 멱등성

부분 장애 → 비결정적

신뢰성 없는 시스템에 래핑해 문제점을 보완

## 신뢰성 없는 네트워크

분산시스템 = 비공유 시스템 (네트워크로 연결된 다수의 장비) ⇒ 네트워크가 통신하는 유일 수단

비동기 패킷 네트워크: 메시지가 언제 도착할지 혹은 도착하기는 할 것인지 보장하지 않음

- 피할 수 없는 네트워크 결함 가능성
    - 케이블이 뽑힐수도.. (요청이 손실)
    - 한 곳에 과부하가 걸렸을 수도.. (요청이 큐에서 대기하다 나중에 전송)
    - 원격 노드에 장애가 생겼을 수도..
    - 응답이 멈쳐줬을 수도..
    - 네트워크에서 손실 될 수도.. (스위치 설정이 잘못될 수도)
    - 네트워크나 요청을 보낸 장비에 과부하

무조건 견디도록 처리할 필요는없다.   타임아웃을 정하고 타임아웃이 날 경우 사용자에게 오류 메시지를 보여주는 것도 타당한 방법
> 그러나 시스템이 어떻게 반응하는지 알고 그로부터 복구할 수 있도록 보장해야한다

- 로드 밸런서는 죽은 노드로 요청을 그만 보내야한다
- 단일 리더 복제를 사용하는 분산 데이터베이스에서 리더가 장애가 나면 팔로워 중 하나가 리더로 승격

너무 타임아웃이 짧으면 시스템의 균형이 깨진다

타임아웃과 기약없는 지연  ⇒ 시간 설정이 간단하지 않음.. 
<del>이상적인 타임아웃 시간 = 전송시간 * 2 + 처리시간 </del>

### 결함 감지

TCP vs UDP (신뢰성과 지연 변동성 사이에 트레이드오프)
지연시간에 민감한 건 UDP / 신뢰성이 필요한건 TCP

### 동기 네트워크 vs 비동기 네트워크 

회선: 통화를 하는 두 명 사이에 있는 전체 결로를 따라서 그 통화에 대해 고정되고 보장된 양의 대역폭이 할당
네트워크 종단 지연 시간의 최대치가 고정 = 제한 있는 지연 

- 동기식 → 큐 대기 문제를 겪지 않음, 다른 사람이 사용할 수 없음  ex) 전화

비동기 네트워크 원리 = 패킷 교환 → 순간적으로 몰리는 트래픽(bursty traffic)에 최적화 

네트워크 지연을 예측 가능하게 만들 수는 없을까?

- 인터넷은 왜 패킷 교환(비동기 네트워크)을 쓸까? 순간적으로 몰리는 트래픽에 최적화
    - 인터넷은 대역폭 요구가 없다. 단지 가능한 빨리 완료되기를 바랄 뿐

지터: 시간에 이상적인 위치에 대해 짧은 시간 나타나는 신호 차이 

## 신뢰성 없는 시계
<del> 사실상 패스 ..</del>
- 네트워크 시간 프로토콜 (NTP) // mac 오랜만에 키면 시간 맞춰줘야하는 것처럼
- 일 기준 시계(날짜 NTP), 단조시계(시간 측정, 내부 클락) // 동기화 
- 컴퓨터 시계는 정확하지 않을 수 있다. ex) 윤초, 딜레이 

### 이벤트 순서화용 타임스탬프

→ 복제, 타임스탬프로 이벤트 순서를 올바르게 정할 수 없다
LWW(Last Write Win): 마지막에 쓰기 작업을 한게 저장이 된다 

### 프로세스 중단

노드가 여전히 리더인지, 안전하게 쓰기를 받아들일 수 있을지?

대안 
- 리더가 다른 노드들로부터 임차권을 얻는 것, 임차권 갱신, 갱신 멈추면 다른 노드가 리더 역할을 받을 수 있도록 (나 살아있어)
    - 동기화된 시계

원인
- 가비지 컬렉터 stop the world
- 가상 장비 서스펜드
- 노트북 덮개 닫기
- 컨텍스트 스위치 (스틸 타임)
- I/O 시간
- 디스크 스왑, 스래싱
- SIGSTOP

분산 시스템은 공유 메모리가 없고.. 단지 신뢰성 없는 네트워크를 통해 메시지를 보낼 수만 있다 

### 응답시간 보장

Real Time Operation System에선? 

- 프로세스가 명시된 간격의 CPU 시간을 할당받을 수 있게 보장되도록 스케줄링 필요 + 보장을 만족시킬 정도의 테스트
- 라이브러리는 최악의 실행 시간을 문서화해야한다
- 실시간 ≠ 고성능 (실시간 = 제때에 응답)

가비지 컬렉션의 영향을 제한 

- 언제 컬렉션을 할지와 관련된 유연성 필요

GC 중단을 노드가 잠시 동안 **계획적으로 중단**되는 것으로 간주 

수명이 짧은 객체만 가비지 컬렉터, **수명이 긴 객체는 프로세스 재시작**

## 지식, 진실, 그리고 거짓말

**진실은 다수결로 결정된다** 

: 비대칭적인 결함이 있는 네트워크에서 (메시지는 받지만 오는게 유실)

- 응답이 늦을 경우 → 안 죽었는데 장례를...
    - 내 응답이 반드시 믿을 수 있는 것은 아니다
    - **정족수**(quorum) 알고리즘 → 합의 알고리즘
    

### 리더와 잠금 

 리더가 아닌데 리더인줄 알고 데이터를 오염 시킬 수 있어 

→ 펜싱 토큰: 너 리더 맞아? (잠금이 승인될 때마다 증가하는 숫자, 토큰 값이 큰걸로 저장)

**클라이언트들이 항상 잘 동작하지 않다**: 토큰을 확인하는 이유 

**주키퍼(잠금 서비스)**

트랜잭선 ID(zxid), 노드 버전(cversion)을 펜싱 토큰으로 사용해

### 비잔틴 결함 
> 노드가 가짜 펜싱토큰을 포함한 메시지를 보낸다면?
지금까진 신뢰성은 없지만 정직하다고 가정
- 체크섬 
- 프로토콜 파싱시 정상성 점검 (sanity-checking)
- 잘못된 서버 확인 (NTP)

### 시스템 모델과 현실 

시스템 모델을 정의해 정형화
- 동기식 모델 
- 부분 동기식 모델
- 비동기식 모델 

알고리즘이 정확성 파악
> 알고리즘 속성을 기술 먼저 

- 유일성: 펜싱 토큰 요청이 같은 값을 반환하지 않음
- 단조 일련번호: 뒤에 토큰이 더 크다
- 가용성: 죽지 않은 노드는 결국 응답을 받음

부분 실패가 생길 수 있다는 사실은 분산 시스템의 뚜렷한 특성

→ 부분 실패에 대한 내성을 소프트웨어에 내장하려고 노력 

### 안정성과 활동성 

- 안정성: 나쁜 일은 일어나지 않는다.
- 활동성: 좋은 일은 결국 일어난다 

최종적 일관성: 활동적 속성
